---
title: "Quosures and Programming on the Language"
author: "Dan Sullivan"
date: "12/5/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


>Expressions have lesser ones upon their backs to bite 'em. 
>Lesser expressions have still lesser ones and so on *ad finitum*.

## Introduction

Quosures enable *Programming on the Language*. This tutorial looks at how they
do that.

*Programming on the Language* is a way of circumventing R's standard evaluation of an
expression and instead use your own code to interpret that expession and then use
that interpretation to perform what ever operations you want. This is called
non-standard evaluation or NSE. Its done to embded
a custom programming langage inside of an R expression.

An example
of this is dplyr::filter which implements a simple programming language for
choosing rows from a table that is more straightforward than the R programming language
for doing that. For example:

```{r simplefilter}
suppressPackageStartupMessages(library(dplyr))
tbl <- tibble::tribble(
	~length, ~width, ~weight,
	10, 20, 110,
	15, 10, 87,
	12, 30, 92,
	15, 20, 99
)
# R language for a filter
tbl[tbl["weight"] < 94 & tbl["length"] > 12, ]
# dplyr language for a filter
filter(tbl, weight < 94, length > 12)
```

The R standard evaluation syntax for a filter 
has more of what is sometimes called *programming ceremony*
than the dplyr syntax. Programming ceremony is the text you need
to type into an expression that has little to do with telling R you what it is
want expression to do.

In the R standard evaluation syntax in this example the
programing ceremony is `tbl` repeated three times, the quotes and square
brackets and even that one *dangling* comma. All of those things are necessary
to get the filter to do what you want it to do but do nothing to clarify what
you want the filter to do. Get one of those pieces of ceremony wrong and only
if you are lucky you will get an error... if you are unlucky the statement will
just silently produce incorrect data.

`dplyr::filter` circumvents the R standard evaluation of its second and third
arguments in this example. It interprets the expressions `weight < 94` 
and `length > 12` with it's own code to associate them with `tbl` and produce the same results 
as the R standard filter.

Here dplyr::filter is using NSE to embed its own programing language for describing how to 
choose rows in a table.

One of the powerful things about using NSE like this is that in many cases, maybe most,
you don't need to know how NSE works, or even that quosures exist, to make use
of an embeded custom language. One of
these cases is when you are using functions that use NSE, like `dplyr::filter`,
from the command line to explore data.

But if you are using NSE functions in a script or you are implementing your own
custom language then you will need to understand how NSE functions work.

And even if you are using it from the command line you may run into edge cases
where a good understanding of how NSE functions will be a big help.


##Language  Operational Components

Language operational components isn't a term from Computer Science, it just, I 
think, describes the parts of a language in terms of how a program, for example written
in the R language, produces its results.

*Programming on the Language* means inspecting, managing and sometimes 
manipulating the language operational components of the R. Quosuers
give you access to these components.

In R, and most programming langauges, you will find three operational components;
Syntax, model and context. Let's take a look at what each is before we go into 
details.

The syntax of a language determines what you are allowed to type when you
write a program. In R, for example you can type

```{r allowed}
a <- 2
b <- 3
# this is allowed in an R program
a + b
```
and R can understand it and process it. But if you type

```{r notallowed, error=TRUE}
# this is not allowed in an R program
+ a b
```

R won't even try to figure out what you are trying to tell it. This happens
because R checks that what you have typed complies with the syntax of R before
it tries to do anything else.

This means that the custom language you are trying to embed inside an R 
expression must comply with the syntax rules for R.

The syntax of a language can be documented in many ways. For R this is done
in Section 10 of the *R Language Definition* 
https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf .

The syntax of a language like R is meant to give people a familiar way to express
what they want a computer to do by writing an English prose-like list of 
directions. In R each one of these directions is called an expression. A big
factor in how useful a programming language is for a particular task is
its syntax. 

However the computer cannot directly understand prose of a programming langauge.
It has to be translated 
into a model the computer can understand directly. I'm going to give that 
model the name *Expression Object Model*. Later you will see why I chose
this name. The *Expression Object Model* is an in memory represenation of an
expression from the programing language and is built
out of objects defined by the implementation of the language.

There can be more than one *Expression Object Model* for a langauge. In R there is one
defined in the c language implementation of R. But another is defined by the rlang 
package... that's the one we'll be using in this tutorial.

What can R do with an *Expression Object Model*? The main thing is to evaluate
it. Evaluation produces a result that can be one or maybe more numbers. Keep
in mind that a string, under the covers, is just a sequence of numbers. When you
run an R program you get back the result of R evaluating the *Expession Object Model*
of each of the expressions in that program.

The evaluation of an *Expression Object Model* is where the context is involved.
Programs are mostly written with symbols that represent values of some kind.

For example in this trivial R program:

```{r trival}
a <- 2
b <- 3
a + b
```

`a` and `b` are symbols. When R goes to sum up those two symbols it has to somehow
find out what their values are. It does this by looking up those symbols in
the context where that evaluation is being done.

In R this context is called an environment. In fact in R the context may be
sequence of multiple environments that R goes through when it needs, or creates,
the value of a symbol.

The `rlang` package implements an *Expression Object Model* of R. A quosure contains
that in memory repesentation of the model. In fact the `rlang` psckage is a wrapper around
the `c` language memory model that R uses to evaluate expressions.

A quosue gives you access to all three of these language operational
components.

The big picture of what we just covered is that a person uses the syntax of R
to write an expression which in turn is translated into in memory model of that expression,
called an *Expression Object Model*. Then R evaluates the *Expression Object Model*
in a context and produces a result.

# HTML And Analog to Quosures

So far the explanation of quosures and how they can be used to change how R interprets
its syntax is a bit on the abstract side. A lot of R users are familar with 
html or at least know that javascript is used to make dynamic web pages.

html is a language, a markup language, and it has language
operational components just like R does. In fact using javascript to make a 
dynamic web page is the same as *programming on the language* in R.

However in html it's a lot easier to 
see the html's equivalent of an *Expression Object Model* in concrete terms.
So let's do that.

Here is a trival example of an HTML page. It's in `trivial.html` from the 
files you can download for this tutorial.

```
<!DOCTYPE html>
<title>A Tivial Example</title>
This is an example of a valid web page.
```

At first glance you might think that this is not a valid web page because it seems
to be missing many tags you probably think are required. For example the is no
`<html>` tag

If you open the `trivial.html` file in your web browser it will display properly.
However opening a file is not a test for html validity... no browsers check html for
validity and will display almost anything given to them.

However if you go to the W3C web page for checking the validity of html at
https://validator.w3.org/#validate_by_input and check this example there you will
find that the syntax, one of the operational components of html, of this page
is correct.

The syntax for html is defined on the W3C site at
https://www.w3.org/TR/html51/ . If you 
dig into it (please don't, it's pretty overwhelming :-)  you will find that many tags
are optional, for example the `<html>` tag https://www.w3.org/TR/html51/semantics.html#the-html-element

So where might you have gotten the idea that the `html` tag and friends are
required? It's probably becasue you more familar with the model component
of html than with it's syntax.

The W3C calls the model component of html the Document Object Model or DOM.
That's where
I got the idea of calling the model component of R expresions the
*Expression Object Model*. The W3C formally documents the DOM at
https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/ . 

The DOM defines a number of objects that can be used to represent html in
memory, just as the `rlang` package does.

Here is an example of the tool that Chrome provides for exploring the DOM, the
equivalent of the *Expression Object Model* for R.

![Visualization of the DOM](htmlmodel.png)

Notice that the *missing* tags seem to have appeared! Actually what you see are
not tags, the are markers that represent objects used in the in memory model of
the html for the page. 

There are some utilitarian differences between the W3C DOM and the `rlang` 
*Expression Object Model*. The W3C formally defines the model component of html
and the `rlang`
package does not. Also out there in 
the wild that are a lot of tools for visually exploring the DOM. In R we don't
have comprehensive tools  to visually explore a quosure.

html, not the DOM, is designed to build a static web page. In classic html the
only way to "liven" up a page by making it change, 
except for some simpistic changes like a drop down menu,
is to request the web site that
originally served up the page to send a new page to the 
browser.

The way you make a dynamic web page, for example the way Shiny does, is to
add some javascript to the page. That javascript examines and manipulates the
DOM, not the html, for the page. When you use javascript like this you are
*programming on the langauge*, the hypertext markup language.

With a quosure you can "program on the language" with the R langauge. 
The usage details are different but "programming on the langauge" in R
is the same thing
as using javascript with html to make dynamic web pages my maipulating
the DOM.

##Components in Action

Before we go further and with only minimal explanation of the code, let's look
at some examples of quosures that use the language operational components in
action. These examples are only meant to show what can be accompished with quosures, the programming details of how this is done is covered later in the tutorial.

###Complexity Measure, Using Syntax

Here is a function that measures the complexity of an expression. It's metric is
pretty simple, the longer the expression the more complex it is. However this 
function needs to access the expression string itself,
in order to implement this metric and it uses a quosure to do this.

```{r complexity}
complexity <- function(expr) {
	# make a quosure of the expression
	q <- rlang::enquo(expr)
	# since a quosure mimics a formula we can get it's text
	stringr::str_length(rlang::f_text(q))
}

complexity(a)
complexity(a + b)
```

So our `complexity` function shows that `a + b` is five times more  complicated
than `a` :-) .

The important thing shown here is that we were able to access the argument
of `complexity` as a string and then process that string any way we please. 
In this case we just got it length but, of course, we could have done much more 
with it.

However there is limitation here. It's not a deal breaker but in the general case
it's pretty significant. The argument of complexity has to be a string that is
allowed by R's syntax. For example you might like use our `complexity` function to
measure the complexity of a lisp expression like this:
```{r, error=TRUE}
complexity((+ a b))
```

As you can see our complexity function never even got to look at the lisp expression
that was passed into it. That's because the first thing R does when a function
is called is to check that each argument is allowed by the R language syntax. If one is not R doesn't go any further and just returns an error.

###Bizzaro World Arithmetic, Using Context

In this example and the next we implement Bizzarro World ( https://en.wikipedia.org/wiki/Bizarro_World ) arithmetic. In
Bizzaro World add means subtract, multiple means divide and *vica versa*.

In this example we use the context of a quosure to implement Bizzarro World
arithmetic and in the next we will use the `rlang` model of an expression
to implement it.

```{r bizzarro}

barithmetic <- function(expr) {
	q <- rlang::enquo(expr)
	# replace the context of the quosure with a new one
	context <- new.env(parent = rlang::get_env(q))
	rlang::set_env(q, context)
	# redefine the arithmetic functions to do bizzarro arithmetic
	# in the context of the quosure.
	# Note that this doesn't change these definitions anywhere else.
	context$`+` <- function(x,y) {x - y}
	context$`-` <- function(x,y) {x + y}
	context$`*` <- function(x,y) {x / y}
	context$`/` <- function(x,y) {x * y}
	# use R to do the evaluation in Bizzarro World
	rlang::eval_tidy(q, context)
}

calc1 <- barithmetic(3 + 1)
# Hmmmm???
calc1
calc2 <- barithmetic(3 * 4 + 1)
#yikes, that's bizzare!!!!
calc2
```

Here we were able to reinterpret the expression passed into `barithmetic` by
manipulating the context component to 
substitute bizzarro arithmetic for regular arithmetic. 

Next we're going to change ggplot2 to use non-Euclidian geometry
for it's plots... ha, ha, just kidding :-).

### Bizzarro World Arithmetic again, Using Model

Now we are going to use the model component of R expressions that the 
`rlang` package uses,
to implement bizzarro arithmetic. This example is going use some of the code
from the files that can be downloaded for this tutorial. The details of how the
functions in this code work won't be explained until later in this tutorial.

This example uses `qtls_make_rlang_table` to extract the model component from
a quosure.

It  then analyzes the model to find all the arithmetic operations
in it and then changes them to their Bizzarro World counterpart. For example 
`+` is changed to `- in the model.

After that it just let's R evaluate the modified model.


```{r}
suppressPackageStartupMessages(library(quotools))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(magrittr))
# regular arithmetic operators and Bizzarro World counterparts
bizzarro_op <- 
	tibble::tribble(
		~ sym, ~ bizzarro_sym,
		"+", "-",
		"-", "=",
		"*" , "/",
		"/", "*")
#flip arithmetic operators into the bizzarro world
bizzarro_flip <- function(q, op_table) {
	# extract the rlang model of the quosure q
	model <- qtls_make_rlang_table(q)
	# need to pass quosure by reference
	qenv <- new.env(parent = rlang::get_env(q))
	qenv$q <- q
	# this finds all the symbols in model that need to be flipped
	symbols <- dplyr::filter(
		model, expr_type == "symbol", expr_text %in% bizzarro_op$sym)
	purrr::walk(
		# walk the paths to each symbol
		symbols$path,
		function(path, qenf) {
			# find Bizzarro World counterpart
			bop <- dplyr::filter(bizzarro_op, sym == qenv$q[[path]])$bizzarro_sym
			# flip it to bizzarro counterpart
			qenv$q[[path]] <- rlang::sym(bop)
		}, qenv)
	 qenv$q
}
barithmetic <- function(expr, op_table) {
	q <- rlang::enquo(expr)
	q <- bizzarro_flip(q, op_table)
	rlang::eval_tidy(q)
}
barithmetic(3 + 1, bizzarro_op)
# hmmm??
#
barithmetic(3 * 4 + 1, bizzarro_op)
#yikes, that's bizzare!!!!
```

Same bizzarro results, but this time we bizzarro'd all the arithmetic operators
in the model component and then let R do the evaluation of the quosure instead
of overrding the arithmetic operators in the context component.
rlang::eval_tidy is doing the evaluation of the quosure with the modified model.

The function `qtls_make_rlang_table` converts the `rlang` model of an expession
into a table. The only rows we care about are ones where the expression
is a symbol.


##Introduction to the `rlang` Model Component

Here is the
content of the model table we used for the `3 * 4 + 1` expression we used
in one of the bizzarro examples

```{r showtable}
suppressPackageStartupMessages(library(quotools))
show_model_table <- function(expr) {
	q <- rlang::enquo(expr)
	print(qtls_make_rlang_table(q))
}
show_model_table(3 * 4 + 1)
```

We'll be covering more details of what is in this table and the model later
but here are a few salient points.

Notice that this  table is representing a tree. The `id` and `parent` 
columns define the structure of the tree. The row with a 0 parent is 
the root of the tree.

We didn't need to turn the model into a table to implement Bizzarro World
arithmetic. The `rlang` package has
functions, which we'll look at later, that will walk through the entire model
but code that  uses them is tedious to write and understand.

With the model as a table you can apply your existing skills for working with
tabular data to do *programming on the languge* rather then working with
low-level functions.

Here is a visualization of the basic tree structure
for the expression `a * b + c * d` based on the id and parent columns.

```{r simpleexp}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(quotools))
suppressPackageStartupMessages(library(DiagrammeR))
q <- rlang::quo(a * b + c * d )
model <- qtls_make_rlang_table(q)
g <- qtls_plot_model(model)
DiagrammeR::render_graph(g, layout = "tree")
```

The `qtls_plot_model` builds a `DiagarmmeR` plot of the model.

As an aside notice that
we were able to re-use the tablular form of the `rlang` model to produce a
plot rather than using all the low-level functions in the `rlang` package to
do this. Later we see other re-uses of the the tabular model component.

Each circle in this illustration is a object in our tree and displays the text
from the expr_text column in the model table. 

Of course the table we just looked at has a lot more infomation in it
than this tree does. The key thing that this diagram illustrates is that
the `rlang` model of a quosure is a tree of node objects that the `rlang`
package uses to model an expression.

At the root of the tree you can see the expression we started with,
`a * b + c * d`. As you move down the tree you can see that it breaks
down the initial expression into smaller an smaller parts.




## Model Details

The introduction to the model in the previous section lossly defined a model as
a tree of objects.  
