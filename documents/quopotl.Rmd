---
title: "Quosures and Programming on the Language"
author: "Dan Sullivan"
date: "12/5/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


>Expressions have lesser ones upon their backs to bite 'em. 
>Lesser expressions have still lesser ones and so on *ad finitum*.

## Introduction

Quosures enable *Programming on the Language*. This tutorial looks what that
means and how to do it.

*Programming on the Language* is a way of circumventing how R evaluates an
expression in the argument of a function that you that evaluation any way you
want. This is called non-standard evaluation or NSE, because you will not be
evaluating the way that R does.

*Programming on the Language* is useful because it lets you, in effect, extend
the R language with syntaxes that better reflect a particular problem domain.

For example when R sees function call like...

`f(tbl, weight < 94)`

... it will evaluate the expression in the second argument and pass TRUE to `f`
if the value of the variable `weight` is less than 94 but otherwise pass FALSE
to 'f'. This is called standard evaluation
because that is the standard way R handles arguments in a function call.

The `dplyr::filter` function evaluates the same syntax in a completly
different way by using quosures and non-standard valuation.

 `filter(tbl, weight < 94, length > 12)`
```{r simplefilter}
suppressPackageStartupMessages(library(dplyr))
tbl <- tibble::tribble(
	~length, ~width, ~weight,
	10, 20, 110,
	15, 10, 87,
	12, 30, 92,
	15, 20, 99
)
# dplyr syntax for choosing rows
filter(tbl, weight < 94, length > 12)
```

`dplyr::filter` doesn't evaluate each argument, like `weight < 94`, individually
as R standard evaluation would. Instead it interprets `weight` and `length` as 
columns of tbl and then uses the second and third arguments as predicates used
to choose rows from `tbl`.

You can, of course, do the same thing with R standard evaluation, like this:

```{R SE}
tbl[tbl["weight"] < 94 & tbl["length"] > 12, ]
```

and you get the same result.

But the R syntax for chosing rows  
has more of what is sometimes called *programming ceremony*
than the `dplyr::filter` syntax. Programming ceremony is the text you need
to type into an expression that has little to do with telling R you what it is
want expression to do.

In the R standard evaluation example the
programing ceremony is `tbl` repeated three times, the quotes and square
brackets and even that one *dangling* comma. All of those things are necessary
to get the R to choose the rows you want but does nothing to clarify what
you want the R to do.

`dplyr::filter` has a syntax with much less ceremony and that is arguably more
straightforward to use. It is also reminiscent of the syntax that SQL
databases use to choose rows.

`dplyr::filter` highlights a key reason making NSE functions... they let you
create a syntax for arguments that is better adapted to accessing data
in table than standard evaluation and that is similar to the syntax used
to access data in an SQL database that many programmers are
already familiar with.

This tutorial is about a way to use quosures to make NSE functions like
`dplyr::filter`. It also covers the issues you can run into when using
NSE functions. 

##Object Models

In order to *program on the language* you need few things. 

First of all you need some way to prevent R from doing a standard evaluation
of the arguments in a function. There are a number of reasons for this but
the most obvious it that R will often produce errors when given an
expression that wasn't meant to be evaluated.

```{r raw1, error = TRUE}
f1 <- function(expr) {
	as.character(expr)
}

f1(az + bz) 
```

The error occurs because `'as.character` function made R do a standard
evaluation of `expr` and R couldn't find `az`.  

You prevent R from doing a standard evaluation by only using functions that 
don't make R do a standard evaluation. Later we will see that there are
quite of few of these but `rlang::enquo` is one of them.

```{r raw2}
f2 <- function(expr) {
	q <- rlang::enquo(expr)
	rlang::get_expr(q)
}

f2(az + bz) 
```

No errors occured when f2 was executed because the `rlang::enquo` doesn't make
R do a standard evaluation of `expr`. It also returns an object called a 
quosure.

There a number of functions in the `rlang` package that can be used with 
quosures. `rlang::get_expr` is one and it returns the literal text of the expresson.

In theory all you is that literal text of the expression
to interpret the expression like `rlang::filter does with its arguments. We
see an example that does this last. Hoever in
practice the literal text is to hard work with and there
are better ways access the information in the expression, which we will see as
this tutorial progresses.


Another thing a quosure gives you access to is an object model for a quosure. In
simple terms for R an object model is just a `list` that breaks out
the details of an expression. Here is an example that breaks out the operator 
between `az` and `bz` from expr:

```{r obj1}
f4 <- function(expr) {
	q <- rlang::enquo(expr)
	q[[c(2,1)]]
}

f4(az + bz) 

```

The syntax used in the subsetting of `q` might not be familiar but we'll cover
what it is doing later in this tutorial.

The important thing illustrated here is that it is possible to break down an
expression into the pieces that make it up. In programming this is called
*parsing* an expression.

Typically when you *program on the language* your are going to have to parse
expressions. And the really important thing here is that you don't write code
to parse the raw text of the expression... in fact that would be very
difficult to do. A quosure will do all that work for you.

Not only can you break an expression into pieces that make it up you can change
it too. Here is an example that does that.

```{r obj2}
f5 <- function(expr) {
	q <- rlang::enquo(expr)
	q[[c(2,1)]] <- rlang::sym("-")
	q
}

f5(az + bz) 

```

And you can see here that `f5` has changed `az + bz` into `az - bz`.

In fact you could have completely changed the expression if wanted to.



have to write code to parse an expression


Language operational components isn't a term from Computer Science, it just, I 
think, describes the parts of a language in terms of how a program, for example written
in the R language, produces its results.

*Programming on the Language* means inspecting, managing and sometimes 
manipulating the language operational components of the R. Quosuers
give you access to these components.

In R, and most programming langauges, you will find three operational components;
Syntax, model and context. Let's take a look at what each is before we go into 
details.

The syntax of a language determines what you are allowed to type when you
write a program. In R, for example you can type

```{r allowed}
a <- 2
b <- 3
# this is allowed in an R program
a + b
```
and R can understand it and process it. But if you type

```{r notallowed, error=TRUE}
# this is not allowed in an R program
+ a b
```

R won't even try to figure out what you are trying to tell it. This happens
because R checks that what you have typed complies with the syntax of R before
it tries to do anything else.

This means that the custom language you are trying to embed inside an R 
expression must comply with the syntax rules for R.

The syntax of a language can be documented in many ways. For R this is done
in Section 10 of the *R Language Definition* 
https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf .

The syntax of a language like R is meant to give people a familiar way to express
what they want a computer to do by writing an English prose-like list of 
directions. In R each one of these directions is called an expression. A big
factor in how useful a programming language is for a particular task is
its syntax. 

However the computer cannot directly understand prose of a programming langauge.
It has to be translated 
into a model the computer can understand directly. I'm going to give that 
model the name *Expression Object Model*. Later you will see why I chose
this name. The *Expression Object Model* is an in memory represenation of an
expression from the programing language and is built
out of objects defined by the implementation of the language.

There can be more than one *Expression Object Model* for a langauge. In R there is one
defined in the c language implementation of R. But another is defined by the rlang 
package... that's the one we'll be using in this tutorial.

What can R do with an *Expression Object Model*? The main thing is to evaluate
it. Evaluation produces a result that can be one or maybe more numbers. Keep
in mind that a string, under the covers, is just a sequence of numbers. When you
run an R program you get back the result of R evaluating the *Expession Object Model*
of each of the expressions in that program.

The evaluation of an *Expression Object Model* is where the context is involved.
Programs are mostly written with symbols that represent values of some kind.

For example in this trivial R program:

```{r trival}
a <- 2
b <- 3
a + b
```

`a` and `b` are symbols. When R goes to sum up those two symbols it has to somehow
find out what their values are. It does this by looking up those symbols in
the context where that evaluation is being done.

In R this context is called an environment. In fact in R the context may be
sequence of multiple environments that R goes through when it needs, or creates,
the value of a symbol.

The `rlang` package implements an *Expression Object Model* of R. A quosure contains
that in memory repesentation of the model. In fact the `rlang` psckage is a wrapper around
the `c` language memory model that R uses to evaluate expressions.

A quosue gives you access to all three of these language operational
components.

The big picture of what we just covered is that a person uses the syntax of R
to write an expression which in turn is translated into in memory model of that expression,
called an *Expression Object Model*. Then R evaluates the *Expression Object Model*
in a context and produces a result.

# HTML And Analog to Quosures

So far the explanation of quosures and how they can be used to change how R interprets
its syntax is a bit on the abstract side. A lot of R users are familar with 
html or at least know that javascript is used to make dynamic web pages.

html is a language, a markup language, and it has language
operational components just like R does. In fact using javascript to make a 
dynamic web page is the same as *programming on the language* in R.

However in html it's a lot easier to 
see the html's equivalent of an *Expression Object Model* in concrete terms.
So let's do that.

Here is a trival example of an HTML page. It's in `trivial.html` from the 
files you can download for this tutorial.

```
<!DOCTYPE html>
<title>A Tivial Example</title>
This is an example of a valid web page.
```

At first glance you might think that this is not a valid web page because it seems
to be missing many tags you probably think are required. For example the is no
`<html>` tag

If you open the `trivial.html` file in your web browser it will display properly.
However opening a file is not a test for html validity... no browsers check html for
validity and will display almost anything given to them.

However if you go to the W3C web page for checking the validity of html at
https://validator.w3.org/#validate_by_input and check this example there you will
find that the syntax, one of the operational components of html, of this page
is correct.

The syntax for html is defined on the W3C site at
https://www.w3.org/TR/html51/ . If you 
dig into it (please don't, it's pretty overwhelming :-)  you will find that many tags
are optional, for example the `<html>` tag https://www.w3.org/TR/html51/semantics.html#the-html-element

So where might you have gotten the idea that the `html` tag and friends are
required? It's probably becasue you more familar with the model component
of html than with it's syntax.

The W3C calls the model component of html the Document Object Model or DOM.
That's where
I got the idea of calling the model component of R expresions the
*Expression Object Model*. The W3C formally documents the DOM at
https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/ . 

The DOM defines a number of objects that can be used to represent html in
memory, just as the `rlang` package does.

Here is an example of the tool that Chrome provides for exploring the DOM, the
equivalent of the *Expression Object Model* for R.

![Visualization of the DOM](htmlmodel.png)

Notice that the *missing* tags seem to have appeared! Actually what you see are
not tags, the are markers that represent objects used in the in memory model of
the html for the page. 

There are some utilitarian differences between the W3C DOM and the `rlang` 
*Expression Object Model*. The W3C formally defines the model component of html
and the `rlang`
package does not. Also out there in 
the wild that are a lot of tools for visually exploring the DOM. In R we don't
have comprehensive tools  to visually explore a quosure.

html, not the DOM, is designed to build a static web page. In classic html the
only way to "liven" up a page by making it change, 
except for some simpistic changes like a drop down menu,
is to request the web site that
originally served up the page to send a new page to the 
browser.

The way you make a dynamic web page, for example the way Shiny does, is to
add some javascript to the page. That javascript examines and manipulates the
DOM, not the html, for the page. When you use javascript like this you are
*programming on the langauge*, the hypertext markup language.

With a quosure you can "program on the language" with the R langauge. 
The usage details are different but "programming on the langauge" in R
is the same thing
as using javascript with html to make dynamic web pages my maipulating
the DOM.

##Components in Action

Before we go further and with only minimal explanation of the code, let's look
at some examples of quosures that use the language operational components in
action. These examples are only meant to show what can be accompished with quosures, the programming details of how this is done is covered later in the tutorial.

###Complexity Measure, Using Syntax

Here is a function that measures the complexity of an expression. It's metric is
pretty simple, the longer the expression the more complex it is. However this 
function needs to access the expression string itself,
in order to implement this metric and it uses a quosure to do this.

```{r complexity}
complexity <- function(expr) {
	# make a quosure of the expression
	q <- rlang::enquo(expr)
	# since a quosure mimics a formula we can get it's text
	stringr::str_length(rlang::f_text(q))
}

complexity(a)
complexity(a + b)
```

So our `complexity` function shows that `a + b` is five times more  complicated
than `a` :-) .

The important thing shown here is that we were able to access the argument
of `complexity` as a string and then process that string any way we please. 
In this case we just got it length but, of course, we could have done much more 
with it.

However there is limitation here. It's not a deal breaker but in the general case
it's pretty significant. The argument of complexity has to be a string that is
allowed by R's syntax. For example you might like use our `complexity` function to
measure the complexity of a lisp expression like this:
```{r, error=TRUE}
complexity((+ a b))
```

As you can see our complexity function never even got to look at the lisp expression
that was passed into it. That's because the first thing R does when a function
is called is to check that each argument is allowed by the R language syntax. If one is not R doesn't go any further and just returns an error.

###Bizzaro World Arithmetic, Using Context

In this example and the next we implement Bizzarro World ( https://en.wikipedia.org/wiki/Bizarro_World ) arithmetic. In
Bizzaro World add means subtract, multiple means divide and *vica versa*.

In this example we use the context of a quosure to implement Bizzarro World
arithmetic and in the next we will use the `rlang` model of an expression
to implement it.

```{r bizzarro}

barithmetic <- function(expr) {
	q <- rlang::enquo(expr)
	# replace the context of the quosure with a new one
	context <- new.env(parent = rlang::get_env(q))
	rlang::set_env(q, context)
	# redefine the arithmetic functions to do bizzarro arithmetic
	# in the context of the quosure.
	# Note that this doesn't change these definitions anywhere else.
	context$`+` <- function(x,y) {x - y}
	context$`-` <- function(x,y) {x + y}
	context$`*` <- function(x,y) {x / y}
	context$`/` <- function(x,y) {x * y}
	# use R to do the evaluation in Bizzarro World
	rlang::eval_tidy(q, context)
}

calc1 <- barithmetic(3 + 1)
# Hmmmm???
calc1
calc2 <- barithmetic(3 * 4 + 1)
#yikes, that's bizzare!!!!
calc2
```

Here we were able to reinterpret the expression passed into `barithmetic` by
manipulating the context component to 
substitute bizzarro arithmetic for regular arithmetic. 

Next we're going to change ggplot2 to use non-Euclidian geometry
for it's plots... ha, ha, just kidding :-).

### Bizzarro World Arithmetic again, Using Model

Now we are going to use the object model of R expressions that the 
`rlang` package uses,
to implement bizzarro arithmetic. This example uses some code
from the files that can be downloaded for this tutorial. The details of how this
this code works won't be fully explained until later in this tutorial.

This example uses `qtls_make_rlang_model` to extract the object model of an
expression from a quosure. Shortly we'll see that that model is a table.

It  then analyzes the model to find all the arithmetic operations
in it and then changes each of them to its Bizzarro World counterpart. For
example `+` is changed to `- in the model.

After that it just let's R evaluate the modified model.


```{r}
suppressPackageStartupMessages(library(quotools))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(magrittr))
# regular arithmetic operators and Bizzarro World counterparts
bizzarro_op <- 
	tibble::tribble(
		~ sym, ~ bizzarro_sym,
		"+", "-",
		"-", "=",
		"*" , "/",
		"/", "*")
#flip arithmetic operators into the Bizzarro World
bizzarro_flip <- function(q) {
	# get the rlang model of the quosure q
	model <- qtls_make_rlang_model(q)
	# we'll need to pass quosure by reference
	qenv <- new.env()
	qenv$q <- q
	# look up operators in the model that need to be flipped
	symbols <- dplyr::filter(
		model, expr_type == "symbol", expr_text %in% bizzarro_op$sym)
	# walk the paths to each operator
	purrr::walk(symbols$path,
		function(path) {
			# find Bizzarro World counterpart for the operator
			bop <- dplyr::filter(bizzarro_op, sym == qenv$q[[path]])$bizzarro_sym
			# flip it to bizzarro counterpart
			qenv$q[[path]] <- rlang::sym(bop)
		})
	 qenv$q
}
barithmetic <- function(expr) {
	q <- rlang::enquo(expr)
	q <- bizzarro_flip(q)
	rlang::eval_tidy(q)
}
barithmetic(3 + 1)
# hmmm??
#
barithmetic(3 * 4 + 1)
#yikes, that's bizzare!!!!
```

Same bizzarro results, but this time we bizzarro'd all the arithmetic operators
in the rlang object model and then gave it back to R to do the evaluation.
rlang::eval_tidy is doing the evaluation of the quosure with the modified model.


##Introduction to the `rlang` Object Model



Here is the
object model we used for the `3 * 4 + 1` expression we used
in the last bizzarro arithmetic example.

```{r showtable}
suppressPackageStartupMessages(library(quotools))
show_model_table <- function(expr) {
	q <- rlang::enquo(expr)
	print(qtls_make_rlang_model(q))
}
show_model_table(3 * 4 + 1)
```

We'll be covering more details of what is in this table and the model later
but here are a few salient points.

Notice that this  table is representing a tree. The `id` and `parent` 
columns define the structure of the tree. The row with a 0 parent is 
the root of the tree.

We didn't need to turn the model into a table to implement Bizzarro World
arithmetic. The `rlang` package has
functions, which we'll look at later, that will walk through the entire model
but code that  uses them is tedious to write and understand.

With the model as a table you can apply your existing skills for working with
tabular data to do *programming on the languge* rather then working with
low-level functions.

Here is a visualization of the basic tree structure
for the expression `a * b + c * d` based on the id and parent columns.

```{r simpleexp}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(quotools))
suppressPackageStartupMessages(library(DiagrammeR))
q <- rlang::quo(a * b + c * d )
model <- qtls_make_rlang_model(q)
g <- qtls_plot_model(model)
DiagrammeR::render_graph(g, layout = "tree")
```

The `qtls_plot_model` builds a `DiagarmmeR` plot of the model.

As an aside notice that
we were able to re-use the tablular form of the `rlang` model to produce a
plot rather than using all the low-level functions in the `rlang` package to
do this. Later we see other re-uses of the the tabular model component.

Each circle in this illustration is a object in our tree and displays the text
from the expr_text column in the model table. 

Of course the table we just looked at has a lot more infomation in it
than this tree does. The key thing that this diagram illustrates is that
the `rlang` model of a quosure is a tree of node objects that the `rlang`
package uses to model an expression.

At the root of the tree you can see the expression we started with,
`a * b + c * d`. As you move down the tree you can see that it breaks
down the initial expression into smaller an smaller parts.




## Model Details

The introduction to the model in the previous section lossly defined a model as
a tree of objects.  
