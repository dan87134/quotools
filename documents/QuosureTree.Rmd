---
title: "Quosure Data Structure"
author: "Dan Sullivan"
date: "12/18/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

A quosure object is a wrapper around an expression. The `typeof` a quosure is
`language` meaning a quosure is a language object. 

```{r typeof}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(quotools))
q <- rlang::quo(a * b + c * d)
typeof(q)
```
R objects seem to implement a single class
inheritance like the Java and C# does, not like the multi-class inheritance that
C++ does. It also seems to implement interfaces as Java and C# do, though it
doesn't seem to be calledthat. Interfaces mean an 
object can mimic the behaviour of many differnt types of objects
without have it inherit from them.


```{r interfaces}
# show all the types of objects q mimics
qtls_what_is_it(q)

```
This shows that a quosure mimics a formula object, so you can treat it like a
formula. In fact a quosure stores the expression it is wrapping in the
rhs (righthand side) of its formula.

```{r rhs}
qrhs <- rlang::f_rhs(q)
qrhs
```

Here you see the expression the quosure is wrapping in the rhs of the quosure.

The typeof the righthand side (rhs) of a quosure is  language but it mimics many
other types of objects.

```{r rhs2}
typeof(qrhs)
qtls_what_is_it(qrhs)
```
Here we see that the rhs mimics an `expr` object so you can treat it as an
expression.

A language object, like the expression we are working on here,
has some properties called car and cdr (pronounced sort of like "c-a-dr").
Don't worry about the strange
names, they come form R's lisp heritige but their original meanings don't
apply here.

These properties can contain, at least in theory, any kind of objects, even
list objects. The rlang package gives you access to them.

```{r lists}
qcar <- rlang::node_car(qrhs)
typeof(qcar)
qcdr <- rlang::node_cdr(qrhs)
typeof(qcdr)
```

Here we see that the car is a `symbol` and the cdr is a pairlist. You probably
haven't see a pairlist before because they are not used, at least not now, in R
applications. But for all practical purposes they are the same thing as a list
object.

That list in the cdr can contain, again in theory, any kinds of objects, 
including expression objects.

Given those a cdr list with expression objects in it then via recursion this can
be used to build a tree. In fact this would then look like a data structure we
call a tree where each object in the tree contains a list of its children.

We see these kinds of tree data structures all over the place. Examples
are the W3C DOM (object model of a web page and XML), the XPath model for XML,
scopes in a programming language, JSON and on and on.

But we kind of left the car behind. The car can contain any kind of object
including a list. But a tree data structure only has a single list of
children. Maybe, by convention, R doesn't ever put a list in the car?

However that convention is not followed by R as we can see here...


```{r mulitplecar}
# anonymous function define and executed
qf <- rlang::quo(function(x){x}(6) )
qfrhs <- rlang::f_rhs(qf)
qfcdr <- rlang::node_cdr(qfrhs)
n2 <- qfcdr[[2]]
n2car <- rlang::node_car(n2)
length(n2)
```

We had to go in 2nd child of the car list of our quosure, but when we do
we see that its car has two children. That means our quosure data structure is
not a tree, certainly not in the conventional sense.

But when we say a data structure
is a tree it is just so that we can have handy visualization to refer to in order
to grasp the its structure without having to think about the detail of it.
But in the end objects have properties and we make use of them in any way we
wish to fulfill the requirements of an application. OK, stepping down from
the soapbox....  :-)

Since the purpose of a tree is to give us a visualization that will help
us understand a data structure without having to look at every detail of it, we
can use a conventions that say the single list of a language element is the
concatonation of the car and cdr lists, with the car coming first. If either
the car or cdr does is not a list then it won't be used to build the *single*
list of our language object. If we do that we get a tree that looks like this
for our anonymous, executed function we just looked at.

```{r mulitreee}
suppressPackageStartupMessages(library(DiagrammeR))
qftab <- qtls_make_rlang_table(qf)
g <- qtls_plot_model(qftab)
DiagrammeR::render_graph(g, layout="tree")
```



One way to do that is the stipulate that the car list will contain no more than one object and that object will not be a language object. Only the cdr list can contain more than one object those objects might be language object.

That stipulation isn't true for R though, we'll see that shortly. But, for a moment, let's  assume that representation is true.

Then we can say can say that the objects in the cdr list are children of the single object in the car list. That way a language object represents two levels of nodes in our tree instead of just one level in a classic tree structure object that has just a single list of children. 

